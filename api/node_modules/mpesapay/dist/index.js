var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/utils/accesstoken.ts
import axios from "axios";
function generateAccessToken(consumerKey, consumerSecret, environment) {
  return __async(this, null, function* () {
    const credentials = Buffer.from(`${consumerKey}:${consumerSecret}`).toString(
      "base64"
    );
    const config = {
      headers: {
        Authorization: `Basic ${credentials}`
      }
    };
    try {
      const response = yield axios.get(
        `${environment}/oauth/v1/generate?grant_type=client_credentials`,
        config
      );
      return response.data.access_token;
    } catch (error) {
      return null;
    }
  });
}

// src/transactions/businesstocustomer/index.ts
import axios2 from "axios";

// src/transactions/businesstocustomer/B2cRequestBody.ts
function initMpesaBusiness2CustomerRequestBody(amount, partyB, remarks, b2cSecurityCredential, callbackUrl, initiator, partyA) {
  return {
    InitiatorName: initiator,
    SecurityCredential: b2cSecurityCredential,
    CommandID: "BusinessPayment",
    Amount: amount,
    PartyA: parseInt(partyA),
    PartyB: partyB,
    Remarks: remarks,
    QueueTimeOutURL: callbackUrl,
    ResultURL: callbackUrl,
    Occassion: remarks
  };
}

// src/utils/Config.ts
function Config(accessToken) {
  return __async(this, null, function* () {
    const config = {
      headers: {
        Authorization: `Bearer ${accessToken}`,
        "Content-Type": "application/json"
      }
    };
    return config;
  });
}

// src/transactions/businesstocustomer/index.ts
function B2C(amount, partyB, remarks, b2cSecurityCredential, callbackUrl, initiator, partyA, accessToken, environment) {
  return __async(this, null, function* () {
    const requestBody = initMpesaBusiness2CustomerRequestBody(
      amount,
      partyB,
      remarks,
      b2cSecurityCredential,
      callbackUrl,
      initiator,
      partyA
    );
    try {
      const response = yield axios2.post(
        `${environment}/mpesa/b2c/v1/paymentrequest`,
        requestBody,
        yield Config(accessToken)
      );
      return response.data;
    } catch (error) {
      return null;
    }
  });
}

// src/utils/timestamp.ts
var timeStamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[^0-9]/g, "").slice(0, -3);

// src/transactions/mpesaexpress/index.ts
import axios3 from "axios";

// src/transactions/mpesaexpress/ExpressRequestBody.ts
function initMpesaExpressRequestBody(amount, phoneNumber, callbackUrl, timeStamp2, password, businessShortCode, accountReference, transactionDesc) {
  return {
    BusinessShortCode: businessShortCode,
    Password: password,
    Timestamp: timeStamp2,
    TransactionType: "CustomerPayBillOnline",
    Amount: amount,
    PartyA: phoneNumber,
    PartyB: businessShortCode,
    PhoneNumber: phoneNumber,
    CallBackURL: callbackUrl,
    AccountReference: accountReference,
    TransactionDesc: transactionDesc
  };
}

// src/utils/Password.ts
function generatePassword(businessShortCode, passKey) {
  return Buffer.from(`${businessShortCode}${passKey}${timeStamp}`).toString(
    "base64"
  );
}

// src/transactions/mpesaexpress/index.ts
function MpesaExpress(amount, phoneNumber, callbackUrl, businessShortCode, passkey, accessToken, environment, accountReference, transactionDesc) {
  return __async(this, null, function* () {
    const password = generatePassword(businessShortCode, passkey);
    const requestBody = initMpesaExpressRequestBody(
      amount,
      phoneNumber,
      callbackUrl,
      timeStamp,
      password,
      businessShortCode,
      accountReference,
      transactionDesc
    );
    try {
      const response = yield axios3.post(
        `${environment}/mpesa/stkpush/v1/processrequest`,
        requestBody,
        yield Config(accessToken)
      );
      return response.data;
    } catch (error) {
      return null;
    }
  });
}

// src/transactions/transactionstatus/index.ts
import axios4 from "axios";

// src/transactions/transactionstatus/transactionRequestBody.ts
function initTransactionStatusRequestBody(transactionId, b2cSecurityCredential, callbackUrl, initiator, partyA) {
  return {
    Initiator: initiator,
    SecurityCredential: b2cSecurityCredential,
    CommandID: "TransactionStatusQuery",
    TransactionID: transactionId,
    PartyA: partyA,
    IdentifierType: "4",
    ResultURL: callbackUrl,
    QueueTimeOutURL: callbackUrl,
    Remarks: "done",
    Occasion: "OK"
  };
}

// src/transactions/transactionstatus/index.ts
function checkTransactionStatus(transactionId, callbackUrl, initiator, accessToken, b2cSecurityCredential, partyA, environment) {
  return __async(this, null, function* () {
    const requestBody = initTransactionStatusRequestBody(
      transactionId,
      b2cSecurityCredential,
      callbackUrl,
      initiator,
      partyA
    );
    try {
      const response = yield axios4.post(
        `${environment}/mpesa/transactionstatus/v1/query`,
        requestBody,
        yield Config(accessToken)
      );
      return response.data;
    } catch (error) {
      return null;
    }
  });
}

// src/transactions/accountbalance/index.ts
import axios5 from "axios";

// src/transactions/accountbalance/balanceRequestBody.ts
function initAccountBalanceRequestBody(partyA, callbackUrl, initiator, b2cSecurityCredential) {
  return {
    Initiator: initiator,
    SecurityCredential: b2cSecurityCredential,
    CommandID: "AccountBalance",
    PartyA: partyA,
    IdentifierType: 4,
    Remarks: "done",
    QueueTimeOutURL: callbackUrl,
    ResultURL: callbackUrl
  };
}

// src/transactions/accountbalance/index.ts
function getAccountBalance(partyA, callbackUrl, initiatorName, b2cSecurityCredential, accessToken, environment) {
  return __async(this, null, function* () {
    const requestBody = initAccountBalanceRequestBody(
      partyA,
      callbackUrl,
      initiatorName,
      b2cSecurityCredential
    );
    try {
      const response = yield axios5.post(
        `${environment}/mpesa/accountbalance/v1/query`,
        requestBody,
        yield Config(accessToken)
      );
      return response.data;
    } catch (error) {
      return null;
    }
  });
}

// src/transactions/mpesapay.ts
var MpesaPay = class {
  constructor(consumerKey, consumerSecret, businessShortCode, passkey, accountReference, transactionDesc, partyA, b2cSecurityCredential, initiatorName, environment = "sandbox") {
    this.consumerKey = consumerKey;
    this.consumerSecret = consumerSecret;
    this.businessShortCode = businessShortCode;
    this.passkey = passkey;
    this.accountReference = accountReference;
    this.transactionDesc = transactionDesc;
    this.partyA = partyA;
    this.b2cSecurityCredential = b2cSecurityCredential;
    this.initiatorName = initiatorName, this.environment = environment === "live" ? "https://api.safaricom.co.ke" : "https://sandbox.safaricom.co.ke";
  }
  //stkpush method for directly initiating a pop to the specified phonenumber with the amount to payed
  //accesstoken
  AccessToken() {
    return __async(this, null, function* () {
      return yield generateAccessToken(
        this.consumerKey,
        this.consumerSecret,
        this.environment
      );
    });
  }
  stkPush(amount, phoneNumber, callbackUrl) {
    return __async(this, null, function* () {
      const accessToken = yield this.AccessToken();
      return yield MpesaExpress(
        amount,
        phoneNumber,
        callbackUrl,
        this.businessShortCode,
        this.passkey,
        accessToken,
        this.environment,
        this.accountReference,
        this.transactionDesc
      );
    });
  }
  transactionStatus(transactionId, callbackUrl) {
    return __async(this, null, function* () {
      const accessToken = yield this.AccessToken();
      return yield checkTransactionStatus(
        transactionId,
        callbackUrl,
        this.initiatorName,
        accessToken,
        this.b2cSecurityCredential,
        this.partyA,
        this.environment
      );
    });
  }
  business2Customer(PaymentAmount, receiversPhonenumber, remarks, callbackUrl) {
    return __async(this, null, function* () {
      const accessToken = yield this.AccessToken();
      return yield B2C(
        PaymentAmount,
        receiversPhonenumber,
        remarks,
        this.b2cSecurityCredential,
        callbackUrl,
        this.initiatorName,
        this.partyA,
        accessToken,
        this.environment
      );
    });
  }
  accountBalance(callbackUrl) {
    return __async(this, null, function* () {
      const accessToken = yield this.AccessToken();
      return yield getAccountBalance(
        this.partyA,
        callbackUrl,
        this.initiatorName,
        this.b2cSecurityCredential,
        accessToken,
        this.environment
      );
    });
  }
};
var mpesapay_default = MpesaPay;

// src/helpers/UniqueReferenceNumber.ts
var usedReferenceNumbers = /* @__PURE__ */ new Set();
function generateUniqueReferenceNumber(prefix, length) {
  let referenceNumber;
  const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  const charactersLength = characters.length;
  do {
    referenceNumber = `${prefix}-`;
    for (let i = 0; i < length; i++) {
      const randomIndex = Math.floor(Math.random() * charactersLength);
      const randomChar = characters.charAt(randomIndex);
      referenceNumber += randomChar;
    }
  } while (usedReferenceNumbers.has(referenceNumber));
  usedReferenceNumbers.add(referenceNumber);
  return referenceNumber;
}

// src/helpers/FormatPaymentData.ts
function FormatPaymentData(data) {
  function extractData(data2) {
    const { Amount, MpesaReceiptNumber, TransactionDate, PhoneNumber } = data2.Body.stkCallback.CallbackMetadata.Item.reduce((acc, item) => {
      acc[item.Name] = item.Value;
      return acc;
    }, {});
    return { Amount, MpesaReceiptNumber, TransactionDate, PhoneNumber };
  }
  const resultscode = data.Body.stkCallback.ResultCode;
  if (data && resultscode === 0) {
    const paymentinfo = extractData(data);
    return {
      status: "success",
      data: {
        Amount: paymentinfo.Amount,
        MpesaReceiptNumber: paymentinfo.MpesaReceiptNumber,
        PhoneNumber: paymentinfo.PhoneNumber,
        TransactionDate: paymentinfo.TransactionDate
      },
      resultCode: resultscode
    };
  } else {
    if (data && resultscode === 17) {
      return {
        status: "failed",
        message: "Unable to process",
        resultCode: resultscode
      };
    } else {
      return {
        status: "canceled",
        message: "Canceled transaction",
        resultCode: resultscode
      };
    }
  }
}

// src/helpers/FormatAccountBalance.ts
function FormatAccountBalance(data) {
  const accountBalanceResult = data.Result.ResultParameters.ResultParameter.find(
    (param) => param.Key === "AccountBalance"
  );
  if (!accountBalanceResult) {
    return {
      resultCode: data.Result.ResultCode,
      status: "failed",
      accountBalances: []
    };
  }
  const accountBalanceString = accountBalanceResult.Value;
  const accountBalanceItems = accountBalanceString.split("&");
  const formattedAccountBalances = accountBalanceItems.map(
    (item) => {
      const [
        accountName,
        currency,
        balance,
        availableBalance,
        reservedAmount,
        unClearedBalance
      ] = item.split("|");
      return {
        accountName,
        currency,
        balance,
        availableBalance,
        reservedAmount,
        unClearedBalance
      };
    }
  );
  return {
    resultCode: data.Result.ResultCode,
    status: "success",
    accountBalances: formattedAccountBalances
  };
}

// src/helpers/FormatBusinessToCustomer.ts
function FormatBusinessToCustomer(data) {
  const resultParameters = data.Result.ResultParameters.ResultParameter;
  const keyMapping = {
    TransactionAmount: "TransactionAmount",
    TransactionReceipt: "TransactionReceipt",
    ReceiverPartyPublicName: "ReceiverPartyPublicName",
    TransactionCompletedDateTime: "TransactionCompletedDateTime",
    B2CUtilityAccountAvailableFunds: "B2CUtilityAccountAvailableFunds",
    B2CWorkingAccountAvailableFunds: "B2CWorkingAccountAvailableFunds",
    B2CRecipientIsRegisteredCustomer: "B2CRecipientIsRegisteredCustomer",
    B2CChargesPaidAccountAvailableFunds: "B2CChargesPaidAccountAvailableFunds"
  };
  const transactionDetails = {
    TransactionAmount: 0,
    TransactionReceipt: "",
    ReceiverPartyPublicName: "",
    TransactionCompletedDateTime: "",
    B2CUtilityAccountAvailableFunds: 0,
    B2CWorkingAccountAvailableFunds: 0,
    B2CRecipientIsRegisteredCustomer: "",
    B2CChargesPaidAccountAvailableFunds: 0
  };
  resultParameters.forEach(({ Key, Value }) => {
    const propertyKey = keyMapping[Key];
    if (propertyKey && typeof Value === "number") {
      transactionDetails[propertyKey] = Value.toString();
    } else if (propertyKey) {
      transactionDetails[propertyKey] = Value.toString();
    }
  });
  if (data.Result.ResultCode === 0) {
    return {
      status: "success",
      resultCode: data.Result.ResultCode,
      data: transactionDetails
    };
  } else {
    return {
      status: "failed",
      resultCode: data.Result.ResultCode
    };
  }
}

// src/index.ts
var src_default = mpesapay_default;
console.log("update");
export {
  FormatAccountBalance,
  FormatBusinessToCustomer,
  FormatPaymentData,
  mpesapay_default as MpesaPay,
  src_default as default,
  generateUniqueReferenceNumber
};
